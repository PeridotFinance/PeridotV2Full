// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaplexEvents {
    #[prost(message, repeated, tag="1")]
    pub events: ::prost::alloc::vec::Vec<MetaplexEvent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaplexEvent {
    #[prost(string, tag="1")]
    pub tx_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag="2")]
    pub block_slot: u64,
    #[prost(message, optional, tag="3")]
    pub block_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint32, tag="4")]
    pub instruction_index: u32,
    /// Address that paid for the transaction
    #[prost(string, tag="5")]
    pub payer_address: ::prost::alloc::string::String,
    /// Account keys relevant to the specific instruction
    ///
    /// For Create: the mint being given metadata. For Update: can be derived or stored.
    #[prost(string, tag="6")]
    pub token_mint_account: ::prost::alloc::string::String,
    /// The PDA of the metadata account
    #[prost(string, tag="7")]
    pub metadata_account: ::prost::alloc::string::String,
    /// Authority for the metadata
    #[prost(string, tag="8")]
    pub update_authority: ::prost::alloc::string::String,
    #[prost(oneof="metaplex_event::EventType", tags="20, 21")]
    pub event_type: ::core::option::Option<metaplex_event::EventType>,
}
/// Nested message and enum types in `MetaplexEvent`.
pub mod metaplex_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EventType {
        #[prost(message, tag="20")]
        CreateMetadataV3(super::CreateMetadataAccountV3Data),
        #[prost(message, tag="21")]
        UpdateMetadataV2(super::UpdateMetadataAccountV2Data),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaplexCreator {
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
    #[prost(bool, tag="2")]
    pub verified: bool,
    #[prost(uint32, tag="3")]
    pub share: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaplexCollection {
    #[prost(bool, tag="1")]
    pub verified: bool,
    /// The mint address of the collection NFT
    #[prost(string, tag="2")]
    pub key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MetaplexUses {
    #[prost(enumeration="MetaplexUseMethod", tag="1")]
    pub use_method: i32,
    #[prost(uint64, tag="2")]
    pub remaining: u64,
    #[prost(uint64, tag="3")]
    pub total: u64,
}
/// Corresponds to the DataV2 struct in Metaplex mpl-token-metadata
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaplexTokenMetadata {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub uri: ::prost::alloc::string::String,
    #[prost(uint32, tag="4")]
    pub seller_fee_basis_points: u32,
    #[prost(message, repeated, tag="5")]
    pub creators: ::prost::alloc::vec::Vec<MetaplexCreator>,
    #[prost(message, optional, tag="6")]
    pub collection: ::core::option::Option<MetaplexCollection>,
    #[prost(message, optional, tag="7")]
    pub uses: ::core::option::Option<MetaplexUses>,
}
/// Corresponds to CollectionDetails enum/struct in Metaplex
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MetaplexCollectionDetails {
    #[prost(oneof="metaplex_collection_details::Details", tags="1")]
    pub details: ::core::option::Option<metaplex_collection_details::Details>,
}
/// Nested message and enum types in `MetaplexCollectionDetails`.
pub mod metaplex_collection_details {
    /// Currently, only V1 is prominent, representing a sized collection.
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct V1 {
        #[prost(uint64, tag="1")]
        pub size: u64,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Details {
        #[prost(message, tag="1")]
        V1(V1),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMetadataAccountV3Data {
    /// mint, mint_authority, payer, update_authority are in the accounts for the instruction
    /// metadata_pda is derived/known
    #[prost(message, optional, tag="1")]
    pub data: ::core::option::Option<MetaplexTokenMetadata>,
    #[prost(bool, tag="2")]
    pub is_mutable: bool,
    #[prost(message, optional, tag="3")]
    pub collection_details: ::core::option::Option<MetaplexCollectionDetails>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMetadataAccountV2Data {
    /// metadata_pda, update_authority (signer) are in the accounts
    ///
    /// Option because not all fields are required for update
    #[prost(message, optional, tag="1")]
    pub data: ::core::option::Option<MetaplexTokenMetadata>,
    #[prost(string, optional, tag="2")]
    pub new_update_authority: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="3")]
    pub primary_sale_happened: ::core::option::Option<bool>,
    /// Can only be flipped to false
    #[prost(bool, optional, tag="4")]
    pub is_mutable: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MetaplexUseMethod {
    Burn = 0,
    Multiple = 1,
    Single = 2,
}
impl MetaplexUseMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MetaplexUseMethod::Burn => "BURN",
            MetaplexUseMethod::Multiple => "MULTIPLE",
            MetaplexUseMethod::Single => "SINGLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BURN" => Some(Self::Burn),
            "MULTIPLE" => Some(Self::Multiple),
            "SINGLE" => Some(Self::Single),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
